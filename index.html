<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Mahjong Blast 3D</title>
<style>
body { margin:0; background:#1e1e2f; font-family:'Segoe UI',sans-serif; overflow:hidden; }
#menu {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    display:flex; flex-direction:column; gap:15px;
}
.menu-btn {
    padding:15px 30px; font-size:24px; color:#fff; background:#333; border:none; border-radius:10px; cursor:pointer; transition:0.3s;
}
.menu-btn:hover { background:#555; }
#game-container { position:relative; width:100vw; height:100vh; overflow:hidden; display:none; perspective:1000px; }
.tile {
    position:absolute; width:80px; height:100px; cursor:pointer;
    transition: transform 0.3s, opacity 0.3s;
    border-radius:8px; box-shadow:0 5px 10px rgba(0,0,0,0.5);
    background-size: cover; background-position: center; z-index:0;
}
.tile.selected { transform:scale(1.2) translateZ(20px); z-index:100; box-shadow:0 10px 20px rgba(255,255,0,0.8); }
.particle { position:absolute; width:10px; height:10px; border-radius:50%; pointer-events:none; }
#inventory {
    position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
    display:flex; gap:10px;
}
.inventory-slot {
    width:60px; height:80px; border:2px solid #fff; border-radius:8px; background:#333;
    display:flex; align-items:center; justify-content:center;
}
.inventory-slot img { max-width:100%; max-height:100%; }
#scoreboard { position:absolute; top:10px; left:50%; transform:translateX(-50%); color:#fff; font-size:20px; }
</style>
</head>
<body>

<div id="menu">
    <button class="menu-btn" data-level="easy">Łatwy</button>
    <button class="menu-btn" data-level="classic">Klasyczny</button>
    <button class="menu-btn" data-level="medium">Średni</button>
    <button class="menu-btn" data-level="hard">Trudny</button>
    <button class="menu-btn" data-level="extreme">Ekstremalny</button>
    <button class="menu-btn" data-level="pro">Zawodowy</button>
    <button class="menu-btn" data-level="random">Wylosuj poziom</button>
</div>

<div id="scoreboard">Punkty: 0</div>
<div id="game-container"></div>
<div id="inventory">
    <div class="inventory-slot" data-slot="0"></div>
    <div class="inventory-slot" data-slot="1"></div>
    <div class="inventory-slot" data-slot="2"></div>
    <div class="inventory-slot" data-slot="3"></div>
</div>

<audio id="click-sound" src="assets/sounds/click.mp3"></audio>
<audio id="match-sound" src="assets/sounds/match.mp3"></audio>

<script>
const menu = document.getElementById('menu');
const container = document.getElementById('game-container');
const clickSound = document.getElementById('click-sound');
const matchSound = document.getElementById('match-sound');
const scoreboard = document.getElementById('scoreboard');
const slots = document.querySelectorAll('.inventory-slot');

let TILE_WIDTH=80, TILE_HEIGHT=100, tiles=[], inventory=[null,null,null,null], score=0, currentLevel='easy';

const LEVELS = { easy:16, classic:32, medium:48, hard:64, extreme:80, pro:128 };
const COLORS = ['red','blue','green','yellow','purple','orange','cyan','magenta'];

function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function shuffle(array){ return array.sort(()=>Math.random()-0.5); }
function updateScore(){ scoreboard.textContent=`Punkty: ${score}`; }

function resetGame(){
    tiles.forEach(t=>t.remove()); tiles=[];
    inventory = [null,null,null,null]; slots.forEach(s=>s.innerHTML=''); score=0; updateScore();
    generatePyramid(currentLevel);
}

function createTile(value,color){
    let tile = document.createElement('div');
    tile.classList.add('tile');
    tile.dataset.value=value;
    tile.style.backgroundImage=`url(assets/images/${(value-1)%16+1}.png)`;
    if(color) tile.style.border=`4px solid ${color}`;
    tile.dataset.layer=0;
    tile.addEventListener('click',()=>tileClick(tile));
    container.appendChild(tile);
    return tile;
}

// Funkcja generuje piramidę warstwową, najmniejsza u góry
function generatePyramid(level){
    tiles.forEach(t=>t.remove()); tiles=[];
    let total=LEVELS[level];
    let baseTiles = Math.ceil(Math.sqrt(total)); // przybliżona liczba wierszy podstawy
    let values=[], pairsNeeded=Math.floor(total/2);
    for(let i=1;i<=pairsNeeded;i++){
        let color = COLORS[randomInt(0,COLORS.length-1)];
        values.push({val:i,color}); values.push({val:i,color});
    }
    values = values.slice(0,total); shuffle(values);

    // Budujemy piramidę warstwowo
    let layer=0;
    let offsetY=50;
    while(values.length>0){
        let layerSize = Math.min(values.length, baseTiles*baseTiles);
        let rowCount = Math.ceil(Math.sqrt(layerSize));
        let colCount = rowCount;
        for(let r=0;r<rowCount;r++){
            for(let c=0;c<colCount;c++){
                if(values.length===0) break;
                let tData = values.pop();
                let tile = createTile(tData.val,tData.color);
                let left = window.innerWidth/2 - (colCount/2*TILE_WIDTH) + c*TILE_WIDTH*0.7 + layer*10;
                let top = offsetY + r*TILE_HEIGHT*0.5 - layer*10;
                tile.style.left = `${left}px`;
                tile.style.top = `${top}px`;
                tile.dataset.layer=layer;
                tile.style.zIndex=layer*10;
                tiles.push(tile);
            }
        }
        layer++; offsetY += rowCount*TILE_HEIGHT*0.5 - 20;
        baseTiles--; // wyższa warstwa mniejsza
    }
    shuffle(tiles);
}

function isTileClickable(tile){
    let layer = parseInt(tile.dataset.layer);
    let tileRect = tile.getBoundingClientRect();
    for(let other of tiles){
        if(other===tile) continue;
        if(parseInt(other.dataset.layer) > layer){
            let otherRect = other.getBoundingClientRect();
            // sprawdź nakładanie
            if(!(tileRect.right<otherRect.left || tileRect.left>otherRect.right || tileRect.bottom<otherRect.top || tileRect.top>otherRect.bottom)){
                return false;
            }
        }
    }
    return true;
}

function tileClick(tile){
    if(!isTileClickable(tile)) return;
    clickSound.currentTime=0; clickSound.play();

    // znajdź pierwszy wolny slot
    let slotIndex = inventory.findIndex(s=>s===null);
    if(slotIndex===-1){
        alert("Ekwipunek pełny! Gra się resetuje.");
        resetGame();
        return;
    }

    inventory[slotIndex]=tile.dataset.value;
    let img=document.createElement('img'); img.src=`assets/images/${tile.dataset.value}.png`;
    slots[slotIndex].appendChild(img);
    tile.style.opacity=0.3;

    // Sprawdzenie pary w ekwipunku
    let counts={};
    inventory.forEach(v=>{ if(v) counts[v]=(counts[v]||0)+1; });
    for(let val in counts){
        if(counts[val]===2){
            inventory = inventory.map(i=>i===val?null:i);
            slots.forEach(s=>{ if(s.firstChild && s.firstChild.src.includes(`${val}.png`)) s.innerHTML=''; });
            score+=10; updateScore();
        }
    }
}

function createParticles(tile){
    for(let i=0;i<15;i++){
        let p=document.createElement('div'); p.classList.add('particle');
        p.style.background=`hsl(${randomInt(0,360)},80%,60%)`;
        p.style.left=`${parseInt(tile.style.left)+TILE_WIDTH/2}px`;
        p.style.top=`${parseInt(tile.style.top)+TILE_HEIGHT/2}px`;
        container.appendChild(p);
        let dx=randomInt(-100,100), dy=randomInt(-100,100), life=randomInt(500,1000);
        p.animate([{transform:`translate(0px,0px)`,opacity:1},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],
                  {duration:life,easing:'ease-out'});
        setTimeout(()=>p.remove(),life);
    }
}

// MENU
menu.querySelectorAll('.menu-btn').forEach(btn=>{
    btn.addEventListener('click',()=>{
        let level = btn.dataset.level;
        if(level==='random'){ const keys=Object.keys(LEVELS); level=keys[randomInt(0,keys.length-1)]; }
        currentLevel=level;
        menu.style.display='none';
        container.style.display='block';
        generatePyramid(level);
    });
});

function gameLoop(){ requestAnimationFrame(gameLoop); }
gameLoop();
</script>

</body>
</html>

